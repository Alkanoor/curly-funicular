Comme on peut le constater, la route n'est pas encore achevée avant de pouvoir disposer d'un contrôleur performant et extensible complètement fiable et imprenable, et de moyens permettant de vérifier cette fiabilité.

Le paradigme SDN est de toute façon, par nature, soumis à des menaces plus importantes. En effet, toute abstraction simplifiant ce qu'elle abstrait, permet avec beaucoup moins d'efforts d'obtenir un résultat équivalent (pensons aux systèmes d'exploitation actuels et à quel point ils nous simplifient la vie de manière considérable en abstrayant les instructions machines). Le même raisonnement peut s'appliquer ici : on peut s'attendre à ce que la gestion du réseau soit plus agréable et simple avec l'adoption de SDN, mais cela repose sur 3 choses :

\begin{itemize}

\item le système d'exploitation réseau doit être fiable (on vient de le voir, c'est très difficile à obtenir, car les menaces sont nombreuses et distantes. Si on revient à la comparaison avec les systèmes d'exploitation au sens classique, certes il est relativement "simple" de compromettre une machine lorsqu'on y a un accès physique, mais ça l'est beaucoup moins en cas d'accès distant. Or avec un système d'exploitation réseau tout n'est qu'accès distant, donc l'accès aux primitives de base du système est plus simple que sur un PC (plus simple de s'immiscer sur un réseau pour y envoyer une instruction Openflow que de s'immiscer sur un PC pour y exécuter une instruction assembleur)). Si des efforts suffisants sont déployés, il est envisageable d'obtenir ce point.
\item la configuration du système doit être scrupuleusement vérifiée. Il y aura globalement moins d'erreurs possibles puisqu'il y a moins de paramètres à configurer à cause de la centralisation partielle du réseau. En revanche, une petite erreur aura de manière générale des conséquences beaucoup plus grandes que dans un réseau classique. Ce point demande donc une vision globale et une vigilance très importante sur ce qui est déployé et configuré sur le contrôleur. Dans l'idéal on peut supprimer un risque important en interdisant le déploiement d'applications qui n'ont pas été vérifiées sur le contrôleur.
\item le système d'exploitation réseau doit être performant. Certes l'exemple de google montre qu'il est possible d'utiliser quasiment 100\% des liens, mais la présence du contrôleur et la nécessité de rediriger certains paquets vers lui peut ralentir le débit global. De plus on ne dispose pas encore de données sur les performances réelles obtenues en production (ce qui est dommage puisque cela ne pousse pas l'industrie frileuse à envisager une adoption progressive de SDN).

\end{itemize}

Si ces trois points sont réunis, il n'y a pas de raison pour que le déploiement de SDN ne se poursuive pas en dehors du champ des grands centres de données (cela reste un avis qui ne prend pas trop en compte la façon dont les réseaux actuels se déploient réellement). ONOS, pour l'avoir étudié d'avantage en détail, me semble un contrôleur prometteur (mais est assez proche d'OpenDayLight dans la structure et la philosophie, donc il est assez difficile de se prononcer sur un éventuel contrôleur représentant SDN qui soit beaucoup plus avancé que ses concurrents). Même si certains contrôleurs comme RoseMary ou SE-floodlight proposent des protections supplémentaires notamment concernant la mémoire bien isolée pour chaque application, la possibilité de distribution d'ONOS (et d'OpenDayLight d'ailleurs) et sa grande extensibilité (possibilité de créer assez facilement des clusters composés de contrôleurs répartis partout dans le monde) lui confèrent un potentiel de déploiement industriel intéressant. 

On pourra si on souhaite déployer un réseau SDN avec le contrôleur ONOS effectuer les points suivants (attention, cela ne garantit pas l'absence de vulnérabilités, mais réduit au moins les risques principaux de prise de contrôle à distance du contrôleur) :
\begin{enumerate}
\item Déployer le contrôleur sur un réseau privé
\item Séparer le réseau privé de gestion et le réseau privé de commutation
\item Sécuriser le conteneur OSGi (donc ici Apache-Karaf), c'est à dire changer tous les identifiants par défaut \footnote{Pour avoir une idée de l'ensemble des manipulations à effectuer, on peut consulter la page https://karaf.apache.org/manual/latest/security} (identifiants généralement stockés dans des fichiers de configuration dans un dossier etc, pour ONOS il s'agit du dossier tools/package/etc/) 
\item Sécuriser les éventuels bundle OSGi rajoutés (permissions les plus basses pour tout nouveau bundle par défaut notamment)
\item Activer TLS\footnote{voir le dernier paragraphe à la page https://wiki.onosproject.org/pages/viewpage.action?pageId=4162614}
\item Activer le Secure-Mode\footnote{https://wiki.onosproject.org/display/ONOS/Enabling+Security-Mode+ONOS}
\item Pour éviter les attaques dues à la non authentification des switchs, il est possible d'utiliser un module assez récent qui ressemble à celui d'OpenDayLight (et qui se nomme d'ailleurs de la même manière), AAA, même si il ne réalise pour le moment que le premier A \footnote{https://wiki.onosproject.org/pages/viewpage.action?pageId=6357336}.
\item Vérifier par la suite toute nouvelle application nécessitant des droits à fort impact pour fonctionner et empêcher le déploiement trop simple de nouvelles applications (ou prévoir des mécanismes robustes pour s'assurer de la confiance à placer dans un dépôt maven externe).
\end{enumerate}

Bien que ce soient là des éléments basiques de configuration, dont certains sont plus faciles à énoncer qu'à appliquer (notamment la vérification de chaque application externe demandant des droits importants), cela constitue une assez bonne première défense contre une majorité d'attaque.